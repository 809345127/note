# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Domain-Driven Design (DDD) example project implemented in Go, demonstrating DDD patterns through a user management and order management system. It uses MySQL as the primary storage backend.

## Common Commands

```bash
# Run application (MySQL storage)
go run .
go run . -port 8080

# Build
make build

# Run tests
make test
go test -v -race -cover ./...

# Lint
make lint

# Format code
make fmt

# Development mode with hot reload (requires air)
make dev

# Install development tools
make install-tools
```

## Architecture

This project follows strict DDD layered architecture with dependency inversion:

```
Presentation Layer (api/) → Application Layer (application/) → Domain Layer (domain/) ← Infrastructure Layer (infrastructure/)
```

### Layer Structure

- **api/**: HTTP handlers, middleware, and response formatting
  - `router.go`: Route aggregation and initialization
  - `{domain}/controller.go`: Controllers grouped by bounded context
  - `middleware/`: Request ID, logging, recovery, CORS, rate limiting
  - `response/`: Unified response and pagination structures

- **application/**: Application services that orchestrate business processes
  - Services depend on repository interfaces, domain services, and UnitOfWork
  - Use UoW.Execute() to wrap operations that modify aggregates
  - Contains DTOs for request/response

- **domain/**: Core business logic (no framework dependencies)
  - `shared/`: Common interfaces (AggregateRoot, DomainEvent, UnitOfWork, Money)
  - `user/`: User aggregate (entity, value objects, repository interface, domain service, events)
  - `order/`: Order aggregate (entity with OrderItem, repository interface, domain service, events)

- **infrastructure/persistence/**: Repository and UoW implementations
  - `context.go`: Transaction propagation via context
  - `mysql/`: MySQL implementations with GORM (UnitOfWork, repositories, PO objects)

### Key DDD Patterns

1. **Aggregate Root**: `User` and `Order` are aggregate roots that maintain consistency boundaries
2. **Value Objects**: `Email`, `Money`, `OrderItem` - immutable, equality by value
3. **Domain Services**: Cross-entity business logic (e.g., `UserDomainService.CanUserPlaceOrder`)
4. **Domain Events**: `UserCreatedEvent`, `OrderPlacedEvent` - generated by aggregates, collected by UoW
5. **Repository**: Persistence abstraction for aggregate roots only
6. **Unit of Work**: Transaction management with context-based tx propagation and event collection
7. **Specification Pattern**: Reusable query criteria objects with AND/OR/NOT composition support

### Unit of Work Usage

Application services use UoW to manage transactions and collect events:

```go
err := s.uow.Execute(ctx, func(ctx context.Context) error {
    // Create aggregate (records events internally)
    user, err := user.NewUser(name, email, age)
    if err != nil {
        return err
    }

    // Save (uses transaction from context)
    if err := s.userRepo.Save(ctx, user); err != nil {
        return err
    }

    // Register for event collection
    s.uow.RegisterNew(user)
    return nil
})
```

Repositories check for transaction in context via `persistence.TxFromContext(ctx)`.

### Critical Design Rules

- **Domain layer has no dependencies** on other layers or frameworks
- **Aggregates generate events internally**, UoW saves them to outbox table
- **Domain services are read-only** - they validate but never call `Save()`
- **Application services orchestrate** - they call domain services and handle persistence
- **Entities use private fields** with accessor methods to protect invariants
- **All modifications to aggregate internals** must go through aggregate root methods
